import{_ as s,c as e,o as a,ae as t}from"./chunks/framework.6g521mOR.js";const c=JSON.parse('{"title":"Slide Puzzle Solver","description":"","frontmatter":{},"headers":[],"relativePath":"projects/Slide_Puzzle_Solver.md","filePath":"projects/Slide_Puzzle_Solver.md"}'),n={name:"projects/Slide_Puzzle_Solver.md"};function r(l,i,h,o,p,d){return a(),e("div",null,i[0]||(i[0]=[t(`<h1 id="slide-puzzle-solver" tabindex="-1">Slide Puzzle Solver <a class="header-anchor" href="#slide-puzzle-solver" aria-label="Permalink to &quot;Slide Puzzle Solver&quot;">​</a></h1><p><strong>Team Members:</strong> Courtney Dickenson<br><strong>Role:</strong> Search Algorithm Design, Heuristic Engineering, Puzzle Modeling<br><strong>Tools:</strong> Python, PriorityQueue, Dataclasses, DFS, IDS, A* Search</p><hr><h2 id="project-overview" tabindex="-1">Project Overview <a class="header-anchor" href="#project-overview" aria-label="Permalink to &quot;Project Overview&quot;">​</a></h2><p>This project addresses the classic <strong>slide puzzle problem</strong>: a 3x3 grid of tiles numbered 1–8 and a blank space. The goal is to transform a given initial configuration into a desired goal state through valid tile moves.</p><p>Three search strategies were implemented to solve this:</p><ul><li><strong>Depth-First Search (DFS)</strong></li><li><strong>Iterative Deepening Search (IDS)</strong></li><li><strong>A* Search</strong> with two admissible heuristics</li></ul><h3 id="key-focus-areas" tabindex="-1">Key Focus Areas: <a class="header-anchor" href="#key-focus-areas" aria-label="Permalink to &quot;Key Focus Areas:&quot;">​</a></h3><ul><li><strong>Tree Search Architecture</strong> – Nodes represent board states with tracked moves and depth.</li><li><strong>Search Strategy Evaluation</strong> – Comparison of search performance across DFS, IDS, and A*.</li><li><strong>Heuristic Design</strong> – Incorporates misplaced tile count and Manhattan distance.</li></ul><hr><h2 id="key-contributions" tabindex="-1">Key Contributions <a class="header-anchor" href="#key-contributions" aria-label="Permalink to &quot;Key Contributions&quot;">​</a></h2><ul><li><strong>Built a Node class</strong> with parent links and move history to trace solution paths.</li><li><strong>Implemented DFS and IDS algorithms</strong> with cycle detection and depth control.</li><li><strong>Developed a robust A* Search engine</strong> using <code>PriorityQueue</code> with heuristic weighting.</li><li><strong>Designed two effective heuristics</strong> for evaluating tile positions.</li></ul><hr><h2 id="system-architecture" tabindex="-1">System Architecture <a class="header-anchor" href="#system-architecture" aria-label="Permalink to &quot;System Architecture&quot;">​</a></h2><h3 id="puzzle-solver-workflow" tabindex="-1">Puzzle Solver Workflow: <a class="header-anchor" href="#puzzle-solver-workflow" aria-label="Permalink to &quot;Puzzle Solver Workflow:&quot;">​</a></h3><ol><li><strong>User Input</strong> – Accepts initial and goal board configurations.</li><li><strong>Node Generation</strong> – States are represented as Nodes, with swap-based move logic.</li><li><strong>Search Algorithm Execution</strong> – DFS, IDS, and A* are run independently.</li><li><strong>Path Reconstruction</strong> – Once a goal is reached, the solution path is backtracked.</li><li><strong>Results Display</strong> – Prints board states step-by-step with total moves.</li></ol><hr><h2 id="algorithm-strategies" tabindex="-1">Algorithm Strategies <a class="header-anchor" href="#algorithm-strategies" aria-label="Permalink to &quot;Algorithm Strategies&quot;">​</a></h2><h3 id="_1-depth-first-search-dfs" tabindex="-1">1. Depth-First Search (DFS) <a class="header-anchor" href="#_1-depth-first-search-dfs" aria-label="Permalink to &quot;1. Depth-First Search (DFS)&quot;">​</a></h3><p>Explores as deep as possible before backtracking, limited by a max depth.</p><p><strong>Pros:</strong> Simple and memory-efficient <strong>Cons:</strong> Can get stuck in deep paths without reaching the goal</p><h3 id="_2-iterative-deepening-search-ids" tabindex="-1">2. Iterative Deepening Search (IDS) <a class="header-anchor" href="#_2-iterative-deepening-search-ids" aria-label="Permalink to &quot;2. Iterative Deepening Search (IDS)&quot;">​</a></h3><p>Combines DFS with incremental depth limits to ensure completeness.</p><p><strong>Pros:</strong> Finds optimal paths with low memory overhead <strong>Cons:</strong> Repeats nodes multiple times</p><h3 id="_3-a-search-with-heuristics" tabindex="-1">3. A* Search with Heuristics <a class="header-anchor" href="#_3-a-search-with-heuristics" aria-label="Permalink to &quot;3. A\\* Search with Heuristics&quot;">​</a></h3><p>Searches based on path cost + heuristic estimate of distance to goal.</p><p><strong>Heuristic 1 – Misplaced Tiles</strong>: Counts tiles out of place.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> heuristic1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, goal):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> goal[i]])</span></span></code></pre></div><p><strong>Heuristic 2 – Manhattan Distance</strong>: Sums distance of each tile from its goal position.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> heuristic2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, goal):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gridVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tile):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> divmod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tile, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tile </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">abs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gridVector(state[i])[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gridVector(goal[i])[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                abs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gridVector(state[i])[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gridVector(goal[i])[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> goal[i]])</span></span></code></pre></div><p><strong>Pros:</strong> Informed search, fast convergence <strong>Cons:</strong> Performance depends heavily on heuristic quality</p><hr><h2 id="results" tabindex="-1">Results <a class="header-anchor" href="#results" aria-label="Permalink to &quot;Results&quot;">​</a></h2><ul><li><strong>DFS</strong>: Found solution within depth limit but not optimal.</li><li><strong>IDS</strong>: Consistently found shortest path with moderate runtime.</li><li><strong>A*</strong>: Fastest with <code>heuristic2</code>, outperforming other strategies in node expansion.</li></ul><hr><h2 id="challenges-and-solutions" tabindex="-1">Challenges and Solutions <a class="header-anchor" href="#challenges-and-solutions" aria-label="Permalink to &quot;Challenges and Solutions&quot;">​</a></h2><h3 id="_1-preventing-cycles-in-dfs" tabindex="-1">1. Preventing Cycles in DFS <a class="header-anchor" href="#_1-preventing-cycles-in-dfs" aria-label="Permalink to &quot;1. Preventing Cycles in DFS&quot;">​</a></h3><ul><li><strong>Fix:</strong> Used hashable state representation and a visited set.</li></ul><h3 id="_2-accurate-distance-heuristic" tabindex="-1">2. Accurate Distance Heuristic <a class="header-anchor" href="#_2-accurate-distance-heuristic" aria-label="Permalink to &quot;2. Accurate Distance Heuristic&quot;">​</a></h3><ul><li><strong>Fix:</strong> Mapped tile positions using index math instead of hardcoding.</li></ul><h3 id="_3-backtracking-path" tabindex="-1">3. Backtracking Path <a class="header-anchor" href="#_3-backtracking-path" aria-label="Permalink to &quot;3. Backtracking Path&quot;">​</a></h3><ul><li><strong>Fix:</strong> Maintained parent references in Node objects and reversed post-traversal.</li></ul><hr><h2 id="future-enhancements" tabindex="-1">Future Enhancements <a class="header-anchor" href="#future-enhancements" aria-label="Permalink to &quot;Future Enhancements&quot;">​</a></h2><ul><li><strong>Support for different puzzle sizes</strong> (e.g., 15-puzzle).</li><li><strong>Interactive visualization</strong> of the puzzle-solving process.</li><li><strong>Dynamic heuristic selection</strong> based on test case complexity.</li></ul><hr><h2 id="key-takeaways" tabindex="-1">Key Takeaways <a class="header-anchor" href="#key-takeaways" aria-label="Permalink to &quot;Key Takeaways&quot;">​</a></h2><ul><li><strong>Classic search strategies</strong> can solve combinatorial puzzles efficiently.</li><li><strong>Heuristic design is critical</strong> for performant informed search.</li><li><strong>Clean Node architecture</strong> enabled easy experimentation with search algorithms.</li></ul><hr>`,49)]))}const g=s(n,[["render",r]]);export{c as __pageData,g as default};
